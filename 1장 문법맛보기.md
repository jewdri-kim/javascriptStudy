# 1장 문법맛보기

## let 키워드

- 정의 : let은 블록 스코프 변수를 선언하는 키워드

- 나타내게된 배경 : 자바스크립트는 변수 스코프가 블록이 아닌 관계로 메뮤리누수memory leck가 발생할 소지가 있으며, 읽기 힘들고 디버깅이 곤란한 프로그램이 쓰여지기 쉽다.

  ​

```javascript
//함수 스코프 변수선언 : let 나타내게된 배경
var a = 12; // 전역
function myFunction() {
    console.log(a);
 
    var b = 13;
    
    if(true) {
        var c = 14;
        console.log(b);
    }        
    console.log(c);
}
myFunction();
```

자바스크립트에서는 if문 밖에서도 변수 c는 접근가능. 다른언어에서는 안된다. 타 언어 개발자는 c가 if문밖에 있으니 undefined 아니냐고 하겠지만. 자바스크립트에서는 그렇지 않다. **이러한 블록스코프 변수를 생성하기 위해 ES6에서는 let 키워드가 탄생했다.**

- let 키워드로 선언한 변수를 블록 스코프 변수라고 한다.
- 선언된 블록안에서만 접근할 수 있다. (함수밖에 선언하면 저역, 블록안에 선언하면 블록밖에서는 접근X)

```javascript
let a = 12; // 전역
function myFunction() {
    console.log(a);
 
    let b = 13;
    
    if(true) {
        let c = 14;
        console.log(b);
    }        
    console.log(c);
}
myFunction();
```

### let에서 var와 달라진 부분

기존 var는 var로 선언한 변수를 다시 var로 선언하면 덮어쓴다.

```javascript
var a = 0;
var a = 1;
console.log(a);
function myFunction() {
    var b = 2;
    var b = 3;
    console.log(b);
}
myFunction();
```

위에 코드가 let 키워드가 된다면?
**Uncaught SyntaxError: Identifier 'a' has already been declared**

```javascript
let a = 0;
let a = 1;
 
function myFunction() {
    let b = 2;
    let b = 3;
    
    if(true) {
        let c = 4;
        let c = 5;
    }
}
myFunction();
```

let 과 var 를 같이 쓴다면 ?

```javascript

var a = 1;
let b = 2;
 
function myFunction() {
    var a = 3;
    let b = 4;
    
    if(true) {
        var a = 5;
        let b = 6;
        
        console.log(a);
        console.log(b);
    }
    
    console.log(a);
    console.log(b);
}
myFunction();
 
console.log(a);
console.log(b);
```

## const 키워드

- ES6 const 키워드는 읽기 전용 변수, 즉 값을 다시 할당할 수 없는 상수를 선언한다. 
- 이 전까지 자바스크립트에서는 상수처럼 보이게 하고 사용 
  ex) var const_pi = 3.14 , var PI = 3.14 
  작업자의 규칙에 의해 상수로 쓰지만, 어딘가에서 고칠수 없게 막을 순 없다.

```javascript
const pi = 3.141;
var r = 2;
 
console.log(pi * r * r);
 
pi = 12;
```

Uncaught TypeError: Assignment to constant variable.

#### 상수스코프

상수는 블록스코프 변수라 let으로 선언한 변수와 스코프 규칙은 같다.

```javascript
const a = 12;
function myFunction() {
    console.log(a);
 
    const b = 13; 
    
    if(true) {
        const c = 14;
        console.log(b);
    }
    console.log(c);
}
 
myFunction();
```

#### 상수를 통한 객체 참조

- 변수에 객체를 할당하면 객체 자신이 아닌, 참조값 reference이 저장되므로 상수에 객체를 할당하면 이 객체의 참조값은 객체가 아닌, 상수에 대해 고정된다. 다시 말해 객체는 가변mutable 상태다.
- 변수 a는 객체의 주소를 담고 잇으므로 불변값이지만 객체 자신은 얼마든지 변경할 수 있다.

```javascript
const a = {
    "name" : "다니엘"
};
 
console.log(a.name);
 
a.name = "옹성우";
 
console.log(a.name);
 
a = {};
```



## 파라미터 기본값

자바스크립트는 함수가 파라미터 값을 받지 못할 때 기본값default value을 지정할 방법이 마땅치 안다.

 그래서 파라미터 값이 undefined이면 기본값을 할당하는 식으로 코딩해왔다.

```javascript
function myFunction(x, y, z) {
    x = x === undefined ? 1 : x;
    y = y === undefined ? 2 : y;
    z = z === undefined ? 3 : z;
 
    console.log(x, y, z);
}
 
myFunction(6, 7);
```

ES6 부터는 ?

```javascript
function myFunction(x = 1, y = 2, z = 3) {
    console.log(x, y, z);
}
 
myFunction(6, 7);
```

```javascript
function myFunction(x = 1, y = 2, z = 3) {
    console.log(x, y, z);
}
 
myFunction(undefined, 7,9);
```

```javascript
function myFunction(x = 1, y = 2, z = 3+5) {
    console.log(x, y, z);
}
 
myFunction(6,7);
```



## 펼침 연산자

- 이터러블 객체를 개별 값으로 나누는 펼침 연산자spread operator는 "..."로 표기한다.

- 이터러블(iterable)

   :ES6 이터러블 규악에 따라 값을 여럿 가지며 개별 값을 순회 가능한 객체다. 배열이 대표적인 이터러블 객체다.


- 펼침 연산자는 함수 인자나 원소(배열)가 여럿 나오는 곳이면 어디라도 쓸 수 있다.
  보통 이터러블 객체를 여러 함수 인자로 펼치는 데 자주 쓴다.
- 배열 값을 함수 인자로 넘기려면 ES5 이전에는 apply() 내장 메소드를 이용

```javascript
function myFunction(a, b) {
    return a + b;
}
 
var data = [1, 4];
var result = myFunction.apply(null, data);
 
console.log(result);
```

위에 코드를 ES6 펼침 연산자를 이용하면?

```javascript
function myFunction(a, b) {
    return a + b;
}
 
let data = [1, 4];
let result = myFunction(...data);
 
console.log(result);
```

자바스크립트 해석기는 ...data를 먼저 1, 4로 치환한 다음 myFunction함수를 호출한다. 
let result = myFunction(...data) -> let result = myFunction(1,4);

※자바스크립트 해석기는 ...data를 먼저 1, 4로 치환한 다음 myFunction함수를 호출한다. 
let result = myFunction(...data) -> let result = myFunction(1,4);



#### 펼침연산자의 다른 용례

- 펼침 연산자는 이터러블 객체를 함수 인자로 펼치는 것뿐만 아니라, 원소가 많이 나오는 곳이면 어디라도 활용가능
- **배열 값을 다른 배열의 일부로 만듬**
  펼침 연산자로 배열 값을 다른 배열에 부분 편입할 수 있다.

ES5 이전에는?

```javascript
var array1 = [2, 3, 4];
var array2 = [1];
 
Array.prototype.push.apply(array2, array1);
 
console.log(array2);
```

ES6 에서는?

```javascript
let array1 = [2, 3, 4];
let array2 = [1];
 
array2.push(...array1);
 
console.log(array2);
```

##### 여러배열 펼침 

:여러 배열을 한 줄의 표현식으로 혈치는 일도 펼침 연산자의 몫이다.

```javascript
let array1 = [1];
let array2 = [2];
let array3 = [...array1, ...array2, ...[3,4]];
let array4 = [5];
 
function myFunction(a, b, c, d, e) {
    return a + b + c + d + e;
}
 
let result = myFunction(...array3, ...array4);
console.log(result)
```



## 나머지 파라미터

나머지 파라미터 rest parameter는 함수의 마지막 파라미터 앞에 "..."를 붙인 것으로, 이름 붙은 파라미터named parameter보다 함수 파라미터를 더 많이 포함한 배열이다.

개수가 가변적인 함수 인자를 포착하는 용도로 쓴다.



ES5 이전엔 arguments 객체로 전달된 함수 인자를 function myFunction(a,b) {    console.log(arguments);    console.log(myFunction.length);    var args = Array.prototype.slice.call(arguments, myFunction.length);    console.log(args);} myFunction(1, 2, 3, 4, 5);썼다. (유사배열객체)

```javascript
function myFunction(a,b) {
    console.log(arguments);
    console.log(myFunction.length);
    var args = Array.prototype.slice.call(arguments, myFunction.length);
    console.log(args);
}
 
myFunction(1, 2, 3, 4, 5);
```

위에 코드를 ES6 의 나머지 파라미터를 쓴다면 ?

```javascript
function myFunction(a, b, ...args) {
    console.log(args);
}
 
myFunction(1, 2, 3, 4, 5);
```

arguments 를 쓰나, ES6 버전의 나머지 파라미터를 쓰나 무슨 차이 ? 

argumentssms 배열 객체가 아니라서 일댄 배열로 바군 다음에야 배열 기능을 이용할 수 있지만, ES6 나머지 파라미터는 그 자체가 배열이라 쉽고 편하게 사용할 수 있다.



arguments 를 쓰나, ES6 버전의 나머지 파라미터를 쓰나 무슨 차이 ? 

argumentssms 배열 객체가 아니라서 일댄 배열로 바군 다음에야 배열 기능을 이용할 수 있지만, ES6 나머지 파라미터는 그 자체가 배열이라 쉽고 편하게 사용할 수 있다.



## 해체할당

해체 할당 destructuring assignment은 이터러블이나 객체의 값/프로퍼티를 각각 배열이나 객체 생성자 리터럴과 비슷한 구문으로 변수에 할당하는 표현식

펄perl 과 파이썬python과 같은 언어에는 기본 내장된 기능

- 배열 해체 할당
- 객체 해체 할당



### 배열해체할당

배열 해체 할당 array destructing assignment은 이터러블 객체에서 값을 추출하여 변수에 할당한다 .배열 생성 리터럴과 닮은꼴이라 이렇게 부른다.ES5 이전에는?



ES5 이전에는?

```javascript
var myArray = [1, 2, 3];
var a = myArray[0];
var b = myArray[1];
var c = myArray[2];
```

ES6 부터는 ?

```javascript
let myArray = [1, 2, 3];
let a, b, c;
[a, b, c] = myArray;
```

```javascript
let [a, b, c] = [1, 2, 3];
```

변수가 배열 원소보다 적을 경우 뒷부분 원소는 무시한다.

**값을 건너뛴다** 
할당 없이 건너뛰어야 할 때도 있다.

```javascript
let [a, ,b] = [1, 2, 3];
console.log(a);
console.log(b);
```

**나머지 연산자를 사용** 
해체 할당시 마지막 변수 앞에 "..."를 붙이면, 원소 값보다 변수가 모자라면 자동으로 배열 객체로 바뀌어 나머지 값들이 할당된다.

```javascript
let [a, ...b] = [1, 2, 3, 4, 5, 6];
console.log(a);
console.log(Array.isArray(b));
console.log(b);
```

```javascript
let [a, , , ...b] = [1, 2, 3, 4, 5, 6];
 
console.log(a);
console.log(b);
```

**변수의 기본값** 해체 할당이 안 된 변수의 기본값을 undefined이외의 값으로 지정할 수 있다.

```javascript
let [a, b, c = 3] = [1, 2];
console.log(c);
```

**중첩 배열 해체** 다차원 배열에서 값을 꺼내어 해체 할당

```javascript
let [a, b, [c, d]] = [1, 2, [3, 4]];
console.log(a);
console.log(b);
console.log(c);
console.log(d);
```

**파라미터로 배열 해체 할당 사용** 해체 할당 표현식을 함수 파라미터 자리에 넣으면 함수에 넘긴 이터러블 객체 값을 추출 할 수 있다.

```javascript
function myFunction([a, b, c = 3]) {
 
    console.log(a, b, c);
}
 
myFunction([1, 2]);
```



### 객체 해체 할당

객체 해체 할당은 객체 프로퍼티 값을 추출해서 변수에 할당한다.



ES5 이전에는 ?

```javascript
var object = {
    "name" : 민호, 
    "age" : 23
};
 
var name = object.name;
var age = object.age;
```

ES6 부터는 ?

```javascript
var object = {
    "name" : "민호", 
    "age" : 23
};
 
let name, age;
 
({name, age} = object);
```

객체 프로퍼티명과 변수명은 반드시 같아야 하나, 다르게 하고 싶을땐 아래처럼.

```javascript
var object = {
    "name" : "민호", 
    "age" : 23
};
 
let x, y;
({name : x, age : y} = object);
 
console.log(x);
console.log(y);
 
```

```javascript
let {name : x, age : y} =  {"name" : "민호", "age" : 23};
console.log(x);
console.log(y);
```

**변수의 기본값**
객체 프로퍼티가 undefined일 경우에 변수에 기본값을 준다.

```javascript
let {a, b, c = 3} = {a: "1", b: "2"}
 
console.log(c);
```

**조합 프로퍼티명을 해체**
프로퍼티명을 동적으로 조합할 경우 표현식을 []로 감싼다.let {a, b, c = 3} = {a: "1", b: "2"}

```javascript
let {["first"+"Name"] : x} = { firstName : "옹성우"};
console.log(x);
```

**중첩 객체를 해체**
중첩 된 객체, 즉 객체 속 객체의 프로퍼티는 다음과 같이 추출

```javascript
let {name, otherInfo: {age}} = {name : "옹성우", otherInfo : {age: 23}};
console.log(name, age);
```

**파라미터로 객체 해체 할당 사용**
배열 해체 할당과 더불어 객체 해체 할당도 함수 파라미터로 가능

```javascript
function myFunction({name  = '다니엘', age = 23, profession = "연예인"} = {}) {
    console.log(name, age, profession);
}
 
myFunction( {name : "옹성우", age: 23}); 
```



## 화살표 함수

